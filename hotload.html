<!DOCTYPE html>
<head>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#0050D0">

<meta name="author" content="David Sun">
<link rel="stylesheet" type="text/css" href="azure.css">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
<title>Creating JVM Classes at Runtime</title>
</head>

<body>
<div id="container">
<section id="body">
<!-- body -->
<svg width="3em" height="3em" style="float:left; vertical-align:middle;            padding-right: 1em">            <a href="index.html">            <rect x="0" y="0" width="3em" height="3em" rx="0.5em" ry="0.5em"/>            </a>            </svg><h1 class="title">Creating JVM Classes at Runtime</h1>
<p>
This is how Lateral Lisp compiles new Lisp to Java Bytecode at runtime.
</p>
<h2>Java Class Loaders</h2>
<p>
The <span class="inlineCode">java.lang.ClassLoader</span> class can allow new classes to be loaded at runtime.
This can be used to load code from a network, or in Lateral's case, to compile
new user defined functions. This allows Lateral to be both fast and highly flexible
at the same time.
</p>
<p>
Class loading is like self-modifying code, but it has all of the safety features
that Java comes with.
With class loaders, a JVM program can extend its functionality while running.
</p>
<h2>Class Generation</h2>
<p>
Compilation happens like usual. Lateral Lisp code is transformed into a Java
class file. However, instead of writing the file to disk, the byte array can be
immediately loaded into the running program.
</p>
<h2>Code</h2>
<div class="codeBlock"><code>class MyClassLoader extends ClassLoader {
    public Class&lt;?&gt; defineClass(byte[] bytes) {
         return defineClass(null, bytes, 0, bytes.length);
    }
}
</code></div>
<p>
The new class is then available to call from existing code. To get a handle on
the new functions, reflection is used to get the new class' methods and store
them in the environment.
</p>
<h2>Notes</h2>
<p>
A loaded class cannot call protected or private methods of a class in the same
package but loaded by another ClassLoader.
</p>
<p>
Classes keep a reference to their <span class="inlineCode">ClassLoader</span>. When there are no more references
to the classes or the ClassLoader, the ClassLoader and <b>the class itself</b> will be
reclaimed by the garbage collector.
</p>
<h2>Sources</h2>
<p>
<a href="https://www.baeldung.com/java-classloaders">https://www.baeldung.com/java-classloaders</a>
</section>
<br>
<hr>
<p><a href="index.html">Home</a></p>
<p>Last updated on 2020-01-19</p></div>
</body>
</html>

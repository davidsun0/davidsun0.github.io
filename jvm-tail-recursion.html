<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#0050D0">

<meta name="author" content="David Sun">
<link rel="stylesheet" type="text/css" href="azure.css">
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
<title>
Tail recursion on the JVM</title>
</head>

<body>
<div id="title">
<svg width="3em" height="3em">
    <a href="index.html">
        <rect class="signum" x="0" y="0" width="3em" height="3em" rx="0.5em" ry="0.5em">
    </a>
</svg>
<h1>
Tail recursion on the JVM</h1>
</div>
<div id="content">
<p>
Functional programming languages express looping and iteration with recursion. </p>
<p>
Programming in a functional style means avoiding mutating objects and variables as much as possible, and in a strictly functional language, the compiler prevents mutation completely. To create looping and iteration, functional programming uses recursion, calling the same function with newly created values. </p>
<p>
Since this is a common construct, compilers optimize tail call recursion to reduce the overhead of function calls and to avoid stack overflows. The result produces JVM bytecode similar to a traditional loop, greatly reducing the cost of recursion. </p>
<h1 id="Optimization-example">Optimization example</h1>
<p>
Essentially, tail recursion optimization is this code transformation: </p>
<pre class="codeBlock"><code>// helper function
int factorial(int n) {
    return factorial(n, 1);
}

// tail recursion optimization transforms code from this...
int factorial(int n, int total) {
    if (n == 1) {
        return total;
    } else {
        return factorial(n - 1, total * n);
    }
}

// to this
int factorial(int n, int total) {
    while (n > 1) {
        total *= n;
        n --;
    }
    return total;
}
</code></pre>
<p>
When applying this transformation, the compiler must not change the semantics; if the lines <code class="inline">total *= n;</code> and <code class="inline">n --;</code> were swapped, the transformed code would be incorrect. </p>
<p>
Careful bytecode generation avoids this problem. If all of the variables are assigned simultaneously, then the semantics of the original code are preserved. </p>
<p>
The following more accurately represents what the optimization does: </p>
<pre class="codeBlock"><code>int factorial(int n, int total) {
    while(true) {
        if (n == 1) {
            return total;
        } else {
            // arguments for the recursive call
            newN = n - 1;
            newTotal = total * n;

            // recursion is transformed into assignment + loop
            n = newN;
            total = newTotal;
        }
    }
}
</code></pre>
<p>
You may have noticed that this implementation of factorial is somewhat different from the classic version. There are two arguments: the value of n and a running total. This is because the typical implementation cannot be optimized. </p>
<p>
The compiler can only convert recursion into a loop under special conditions. The requirement is that the recursive call must be in the <strong>tail position</strong>, which gives the concept its name. </p>
<h1 id="What-is-the-tail-position?">What is the tail position?</h1>
<p>
Tail recursion optimization can only happen when the recursive call is in the tail position. Identifying and transforming tail recursion is simple compared to optimizing recursive calls in general. </p>
<p>
To put it simply, the tail call is the last function called before the return statement. </p>
<p>
In the traditional factorial function, the factorial is not in the tail position, the mutliplication is. </p>
<pre class="codeBlock"><code>int factorial(int n) {
    if (n == 1) {
        return 1;
    } else {
        // multiplication is in the tail position, not factorial
        return n * factorial(n - 1);
    }
}
</code></pre>
<p>
In functional programming, it becomes the programmer's responsibility to write functions that are tail recursive. </p>
<p>
When you are first learning functional programming, it can be easier to do the opposite: first create a looping function, then convert it to a tail recursive form. This can be beneficial in the long term as it will help you identify unnecessary recursion. </p>
<pre class="codeBlock"><code>int factorial(int n) {
    int total = 1;
    for(; n > 1; n--) {
        total *= n;
    }
}
</code></pre>
<p>
A tail recursive function just has the iteration variable as one of its arguments. In this case, the other argument, total, acts like an accumulator. </p>
<pre class="codeBlock"><code><span class="lisp-paren">(</span><span class="lisp-special">defun </span><span class="lisp-symbol">factorial </span><span class="lisp-paren">(</span><span class="lisp-symbol">n</span><span class="lisp-paren">)
  </span><span class="lisp-comment">;; flet defines an inner function
  </span><span class="lisp-paren">(</span><span class="lisp-symbol">flet </span><span class="lisp-paren">(</span><span class="lisp-symbol">(helper </span><span class="lisp-paren">(</span><span class="lisp-symbol">i total</span><span class="lisp-paren">)
           (</span><span class="lisp-special">if </span><span class="lisp-paren">(</span><span class="lisp-symbol">= i 1</span><span class="lisp-paren">)
             </span><span class="lisp-symbol">total </span><span class="lisp-comment">; implicit return
             </span><span class="lisp-paren">(</span><span class="lisp-symbol">helper </span><span class="lisp-paren">(</span><span class="lisp-symbol">-1 i</span><span class="lisp-paren">) (</span><span class="lisp-symbol">* i total</span><span class="lisp-paren">)))))
    </span><span class="lisp-comment">;; begin the iteration with i=n and total=1
    </span><span class="lisp-paren">(</span><span class="lisp-symbol">helper n 1</span><span class="lisp-paren">)))</span></code></pre>
<p>
Since the Lisp family has implicit returns, the tail position is calculated recursively. Only special forms may contain things in the tail position because none of the arguments to a regular function call can be in the tail position (a function can never return the argument of an inner function call). Since there are only a handful of special cases in Lisp, its easy to cover all possible cases. </p>
<p>
These things are in the tail position: </p>
<ul>
<li>both the then and else (but not the test) of an <code class="inline">if</code> </li>
<li>any of the else clauses in a <code class="inline">cond</code> </li>
<li>the body (but not the bindings) of a <code class="inline">let</code>, <code class="inline">let*</code>, <code class="inline">flet</code>, etc </li>
<li>the last term in a <code class="inline">progn</code> (also called <code class="inline">begin</code> or <code class="inline">do</code>) </li>
<li>the last term in an <code class="inline">and</code> or <code class="inline">or</code> </li>
</ul>
<p>
And if one of those items is a recursive call, the compiler can perform tail recursion optimization. </p>
<h2 id="Generating-bytecode">Generating bytecode</h2>
<p>
Inside each method, the JVM provides slots for local variables as well as a stack, which is where most operations take place. The slots are also used to pass arguments. This means that if we modify the local variables and jump to the beginning of the method, it will appear as if the function recursed with new values. </p>
<p>
Plan of action: </p>
<ul>
<li>evaluate the arguments of the tail recursion, saving them on the stack </li>
<li>move the arguments from the stack into the correct local variables </li>
<li>ensure that the stack is empty </li>
<li>goto the start of the method </li>
</ul>
<p>
In the factorial example, changing the instruction order changed the behavior of the program. To avoid data dependency issues, save the recursion arguments on the stack. Moving the arguments from the stack into the local variables all at once performs simultaneous assignment. </p>
<p>
Doing this also keeps recursive calls analagous to regular function calls, which consume arguments from the top of the call stack. </p>
<p>
The stack needs to be cleared to return the method's state to that of a fresh method call. </p>
<h2 id="When-generating-code-by-hand">When generating code by hand</h2>
<p>
If you're using a library to generate code, you can ignore this section. Any JVM code generation library will take care of these details. </p>
<p>
Remember that the top item on the stack is the last argument. In <code class="inline">f(a, b, c);</code>, <code class="inline">c</code> will be on the top of the stack and <code class="inline">a</code> will be the third from the top. </p>
<p>
More importantly, there needs to be a StackMapTable frame for creating the loop. The frame should be easy to generate as there will be nothing on the stack at the start of the method. </p>
<h1 id="Tail-call-optimization">Tail call optimization</h1>
<p>
Tail call recursion is a special case of a more general idea: general tail call optimization optimizes calls to any function in the tail position. </p>
<p>
The JVM enforces strict rules for the sake of safety which prevents general tail call optimization. While there have been proposals for TCO in the past, none of them have been incorporated into the standard. </p>
<p>
If two functions are mutually recursive, then the compiler can't perform optimization on the JVM. A more aggressive compiler could inline mutually recurive functions into a single larger function, but that would simply cause more issues: e.g. Error handling with Java exceptions would become very difficult and the compiler might hit <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.11">JVM limits</a> on code size. </p>
<p>
Other languages not bound to the JVM can strictly enforce tail call optimization. As a part of the standard, <a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-8.html#node_sec_5.11">Scheme guarantees</a> that an infinite number of tail calls will produce a finite number of stack frames. </p>
<p>
TCO may be included in the JVM in the future, but it is  <a href="https://softwareengineering.stackexchange.com/questions/272061/why-doesnt-java-have-optimization-for-tail-recursion-at-all/272086#272086">not coming soon</a> . <br><hr>
<p><a href="index.html">Home</a></p>
<p class="note">Created on 2020-01-20 - Last updated on 2021-02-21</p></div>
</body>
</html>

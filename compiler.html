<!DOCTYPE html>
<head>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#0050D0">

<meta name="author" content="David Sun">
<link rel="stylesheet" type="text/css" href="azure.css">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
<title>Compiling Tail Recursive Functions</title>
</head>

<body>
<div id="container">
<section id="body">
<!-- body -->
<div><svg width="3em" height="3em" style="float:left; vertical-align:middle;            padding-right: 1em">            <a href="index.html">            <rect x="0" y="0" width="3em" height="3em" rx="0.5em" ry="0.5em"/>            </a>            </svg><h1>Compiling Tail Recursive Functions</h1></div>
<h2>Benefits of tail recursion</h2><p>
Lateral Lisp has no for or while loops. For Lisps, it is often more natural
to express looping with recursion.
</p>
<p>
Implementing recursion in the style of a language like C can be inefficient
because an additional call frame needs to be added to the stack for every
recurisve call.
</p>
<p>
Tail call optimization allows a recursive call in the tail position to be
implemented as a GOTO to the beginning of the function. No new frame needs to
be allocated.
</p>
<p>
In fact, from a bytecode or assembly point of view, tail optimized recursion is
identical to a while loop. If the base case is reached, the loop breaks.
Otherwise, the code is repeated with new arguments.
</p>
<h2>What is the tail position?</h2>
<p>
Is a recursive call in the tail position? If the function returns the result of
the call without any further processing, the function is in the tail position.
</p>
<p>
In Lateral, functions can only have one function call in the body. This call
must be in the tail position.
</p>
<h2>Generating bytecode</h2>
<p>
Java has local variables as well as variables on the function's stack. Lateral
operates almost exclusively on the stack.
</p>
<p>
The first n local variables are set to the arguments of the function when it is
called. Therefore, if we replace those variables and jump to the start of the
function, it will be like the function was just called with those new variables.
</p>
<p>
Plan of action:
<ul><li>Store the n variables currently on the stack into the local variables.
</li><li>Be sure that the stack is empty (that's the way the function was when it was
first called!)
</li><li>Jump to the beginning of the function
</li></ul></p>
<p>
Storing the variables on the stack should be done in reverse order. The JVM's
calling convention is to have the last argument on the top of the stack.
</p>
<div class="codeBlock"><code>[C] &lt;-top
[B]
[A]
</code></div><p>
if function f is called right now with three arguments, it will be equivalent to
<code class="inlineCode">f(A, B, C)</code>. We know the number of arguments the function has, so we can count
down to zero.
</p>
<div class="codeBlock"><code>store_local 2
store_local 1
store_local 0
goto start
</code></div>
<p>
Start must be bytecode offset 0, and JVM's goto uses relative offsets, so the
offset is simply the negation of the current byte offset. If the goto happens
100 bytes into the function, the offset is -100.
</p>
<p>
The JVM requires stack information at all jump targets, so the compiler must
insert a frame indicating that there are 0 items on the stack at the beginning
of the function. The JVM will verify it, so if the compiler miscalculates the
number of objects on the stack, the program won't run.
</p>
</section>
<br>
<hr>
<p><a href="index.html">Home</a></p>
<p>Last updated on 2020-01-18</p></div>
</body>
</html>

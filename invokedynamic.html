<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#0050D0">

<meta name="author" content="David Sun">
<link rel="stylesheet" type="text/css" href="azure.css">
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
<title>InvokeDynamic: The best JVM instruction</title>
</head>

<body>
<div id="container">
<section id="body">
<!-- body -->
<svg width="3em" height="3em" style="float:left; vertical-align:middle;padding-right: 1em">
<a href="index.html"><rect x="0" y="0" width="3em" height="3em" rx="0.5em" ry="0.5em"/></a>
</svg>
<h1 class="title" id="InvokeDynamic: The best JVM instruction">InvokeDynamic: The best JVM instruction</h1>
<p>
The Java Virtual Machine (JVM) is becomming a popular target for new languages.
While writing my own, I learned about the invokedynamic instruction, which is
very useful for implementing - wait for it - dynamic languages.
</p>
<p>
There are very few invokedynamic resources out on the internet, and they are
typically geared towards JVM developers and people who know what they're doing.
This guide is for casual users of invokedynamic - e.g. amateur compiler writers
looking to target the JVM for their dynamic language.
</p>
<h2 id="Contents">Contents</h2>
<ul><li><a href="#what<i>is</i>indy">What is invokedynamic?</a>
</li><li><a href="#why<i>use</i>indy">Why use invokedynamic?</a>
</li><li><a href="#indy<i>cant</i>do">What invokedynamic can't do</a>
</li><li><a href="#examples">Uses of invokedynamic</a>
</li><li><a href="#howto">How to use it</a>
</li><li><a href="#dynamic_constants">Dynamic constants</a>
</li><li><a href="#sources">Sources</a>
</li></ul>
<p>
<h1 id="what<i>is</i>indy">What is invokedynamic?</h1>
</p>
<p>
First of all, what is a dynamic language? Dynamic languages like Ruby or Python
don't do type checking at compile time. Every method in Java must explicitly
declare the types of its arguments and its return types, but dynamic languages
don't. All type checking is performed on the fly, and type errors are runtime
errors instead of compiler errors.
</p>
<p>
The Java bytecode contains four other invoke instructions, all for calling
methods:
<ul><li>invokestatic for static methods
</li><li>invokeinterface for interface methods
</li><li>invokespecial for class and object initializers
</li><li>invokevirtual for <a href="https://en.wikipedia.org/wiki/Virtual_function">virtual methods</a>
</li></ul></p>
<p>
Note: virtual methods are all all the method calls on an object like
<code>myObject.doSomething();</code>.
With these four instructions, you can call any method on the JVM.
</p>
<p>
Unlike the other members of the invoke family, invokedynamic isn't made for
calling a certain type of method, it's for calling methods <i>at a certain time</i>.
An invokedynamic instruction only contains a vague idea of the method it wants to
call. At runtime, an actual method will be looked up with a bootstrap method in
a process similar to Java's reflection API.
</p>
<p>
This makes invokedynamic a powerful tool. It exposes parts of the JVM's internal
features like just in time compilation to the programmer.
</p>
<p>
<h1 id="why<i>use</i>indy">Why use invokedynamic?</h1>
</p>
<p>
Java is sold on its safety. Since Java is a static language, the compiler makes
sure that code is <i>type safe</i> - 
objects have to be explicity cast from one type to another.
To provide this type safety, Java has strict requirements when calling a function.
The types of all the arguments and the type of the return value must be known.
Dynamic languages may not know object types at compile time, and passing around
everything as type <code>Object</code> comes with its downsides.
</p>
<p>
Historically, the work around has been to use Java's reflection API to inspect
and select which methods to run. However, this has kown performance penalties.
One of the features of invokedynamic is to
provide better performance over reflection. Be aware that invokedyanmic cannot
replace reflection all of the time and invokedynamic can do more than just
replicate reflection.
</p>
<p>
One of the most surprising ways invokedynamic can be used is with MethodHandles.
MethodHandles can piece together existing methods and control statements in a way
that verges on writing new code at runtime (there are some limitations).
</p>
<p>
<h1 id="indy<i>cant</i>do">What invokedynamic can't do</h1>
</p>
<p>
While invokedynamic is powerful, it still is a "low level" feature.
One of the most attractive features of dynamic languages is multiple dispatch,
which invokdeynamic does not directly support. However, <code>jdk.dynalink</code> does
build multiple dispatch on top of invokedynamic and is used in JVM implementations
of Javascript.
</p>
<p>
With multiple dispatch, which method is called is based on the types of the
objects at runtime.
</p>
<h2 id="Example:">Example:</h2>
<code class="codeBlock">public class TestGadget {
    static void identify(Integer i) {
        System.out.println(i + &quot; is an Integer!&quot;);
    }

    static void identify(String s) {
        System.out.println(s + &quot; is a String!&quot;);
    }

    static void identify(Object object) {
        System.out.println(&quot;Not sure what &quot; + object.toString() + &quot; is.&quot;);
    }

    public static void main(String[] args) {
        Object actuallyAnInt = 12345;
        Object actuallyAString = &quot;Hello World!&quot;;
        TestGadget.identify(actuallyAnInt);
        TestGadget.identify(actuallyAString);
    }
}
</code>
<p>
This code outputs:
</p>
<code class="codeBlock">Not sure what 12345 is.
Not sure what Hello World! is.
</code>
<p>
The Object version of the identify method is called just because the arguments
were cast to objects. Even though actuallyAnInt is an Integer, it is considered
an Object at compile time. In Java, dispatch only occurs on non-static methods
with the object it's called on.
</p>
<p>
Similarly, invokedynamic does not provide dynamic dispatch on the arguments.
The JVM has dynamic disptach based on the object identity: <code>object.toString()</code>
calls the appropriate method based on <code>object</code>'s true type.
</p>
<p>
<h1 id="examples">Uses of Invokedynamic</h1>
</p>
<h2 id="Calling a method that doesn't exist yet">Calling a method that doesn't exist yet</h2>
<p>
Invokedyanmic can be helpful when your code needs to interface with code that
doesn't exist yet. The JVM allows for classes to be generated
at runtime. Your library may have to integrate with user code.
</p>
<p>
With invokedynamic, you can find the method you want to call at runtime
and that method call is essentially "installed" into the code. This eliminates
the overhead of reflection and allows the JVM to perform optimizations as if
the method had been directly called.
</p>
<h2 id="Changing what method is being called">Changing what method is being called</h2>
<p>
The invoke library provides ways to change the invokedyanmic CallSite during
the course of the program. MutableCallSite and VolatileCallSite can change
the behavior of the invokedynamic site after binding. This allows code
to be redefined and modified long after compilation.
</p>
<h2 id="Modifying how a method is called">Modifying how a method is called</h2>
<p>
Functionality provided by MethodHandles:
</p>
<ul><li>Inserting constant objects and binding objects to virtual calls
</li><li>Reordering and preprocessing arguments
</li><li>Packing and unpacking arguments from arrays
</li><li><code>if</code> expressions, <code>for</code>, <code>while</code> loops, exception throwing and handling and more!
</li></ul>
<h2 id="Calling a method without knowing its types">Calling a method without knowing its types</h2>
<p>
This is the use I saw the most. If you don't know an object's type at compile
time, you can't know which method to call. However, if you know that the type
won't change during run time, you can use <code>instanceof</code> and invokedynamic to
select the right method during run time.
</p>
<h1 id="How to use invokedynamic">How to use invokedynamic</h1>
<p>
As of 2020, Java cannot directly call invokedynamic. The command is only used
when compiling lambdas and string concatenation.
</p>
<p>
The "I need to get stuff done" option is to use the ASM library. It is a Java
library for generating and analyzing JVM bytecode. The ASM library handles most
of the tedious parts of making an inovkedynamic call. This is what Java uses ASM
internally to implement lambdas.
</p>
<p>
The "I actually enjoy staring at hex" option is to generate bytecode directly.
The <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.10">JVM specification</a>
describes all the necessary pieces needed to get it working.
</p>
<p>
<h1 id="howto">Invokedyanmic basics</h1>
</p>
<p>
The actual invokedynamic instruction is located at the method <i>call site</i>.
The method used to find the method to be called is known as the <i>bootstrap method</i>.
</p>
<p>
When the code execution first reaches the call site, the bootstrap method is called.
The bootstrap method returns a CallSite object. This object
is installed at the location of the invokedynamic instruction.
On future passes, the bootstrap method is not called and the CallSite object
is used to directly make a method call.
</p>
<p>
CallSites are created from MethodHandles.
MethodHandle is like reflection's Method, but they acheive different goals.
When working with invokedynamic, the two compliment each other and are often used together.
For example, reflection may be used to find a method with a certain name or property.
Then MethodHandles.Lookup can unreflect the Method to create a MethodHandle.
The MethodHandle can then be used to create a CallSite for an invokedynamic instruction.
</p>
<p>
Alternatively, a MethodHandle can be found with MethodHandles.Lookup. Lookup
finds methods while obeying access rules. The object that contains the
invokedynamic instruction must have access to call a private method.
The Lookup object is automatically created with the permissions of the caller.
</p>
<p>
MethodHandles also provides methods to create a new MethodHandle out of thin air.
This includes accessing arrays, throwing exceptions, and creating constant values.
Together, MethodHandle and MethodHandles provide ways to manipulate how the
MethodHandle objects are called.
</p>
<code class="codeBlock">
void myMethod() {
    ...

    // this is pseudocode; invokedynamic cannot be called directly in Java.
    invokedynamic(
        // bootstrap arguments (these are compile-time constants)
        &quot;myDynamicMethod&quot;, MethodType.methodType(...),
        
        // bootstrap information
        MyClass::myBootstrapMethod);
}


public static CallSite myBootstrapMethod(MethodHandles.Lookup lookup,
    String methodName, MethodType expectedType) {
    // your code here
    return callSite;
}
</code>

<p>
The invokedyanmic handle contains the expected method name, argument types, and
return type.
In this way it is still quite similar to the other invoke instructions.
The CallSite returned by the bootstrap method must conform to the handle's type
or an exception will be thrown.
</p>
<p>
The invokedynamic instruction must specify a bootstrap method and its argument
types. The Lookup object is generated by the JVM automatically. The name and type
are constants that are associated with the invokedynamic instruction.
Aside from the Lookup, String, and MethodType arguments as shown in the
example above, the invokedynamic can also pass constant arguments to the bootstrap
method. These additional arguments must be Java primitives or Strings.
</p>
<p>
Bootstrap doesn't have to be <code>public static</code>, an object can call its own non-static
or private bootstrap method.
</p>
<p>
<h1 id="dynamic_constants">Dynamic constants</h1>
</p>
<p>
Dynamic constants are a closely related feature to invokedynamic.
At runtime, an object can be generated which is then treated like a constant in
the the code.
</p>
<p>
Instead of binding a method to the call site,
an object is created at runtime and then bound to the dynamic constant site.
Like invokedynamic, the first time a dynamic constant instruction is run,
a constant bootstrap method is called. This method returns an object.
</p>
<p>
The signature of the bootstrap method is somewhat different:
</p>
<code class="codeBlock">T myConstantBootstrap(MethodHandle.Lookup lookup,
        String name, Class&lt;?&gt; expectedType) {
    // return type T must match the expected type
    return new T();
}
</code>
<p>
Well actually, there isn't an invoke constant instruction. Ldc, the instruction
used to load most other constants in Java, is also used for dynamic constants.
</p>
<p>
Like invokedynamic, extra information can be passed to the bootstrap method
in the form of primitive values and Strings.
</p>
<p>
Information about the bootstrap method is attatched to the ldc instruction,
just like invokedynamic.
</p>
<h1 id="Things I don't know">Things I don't know</h1>
<p>
As a disclaimer, I am not an Oracle engineer and I have not read the Hotspot JVM
source code. This article was written in hopes that it will be a useful explanation
of invokedynamic (but also as a guide for myself).
</p>
<p>
This is what is known in the community as the "further research" section.
</p>
<h2 id="Questions:">Questions:</h2>
<ul><li>Can different objects have different bound methods? (probably not, it seems)
</li><li>Are CallSites garbage collected if the Class with the invokedynamic
instruction is collected?
</li><li>What is the performance of invokedynamic?
</li></ul>
<p>
<h1 id="sources">Sources / Further Reading</h1>
</p>
<ul><li><a href="https://en.wikipedia.org/wiki/Dynamic<i>programming</i>language">Dynamic Programming Language (Wikipedia)</a>
</li><li><a href="https://www.infoq.com/articles/Invokedynamic-Javas-secret-weapon/">Invokedynamic - Java's Secret Weapon</a>
</li><li><a href="https://www.javaworld.com/article/2860079/invokedynamic-101.html">Invokedynamic 101</a>
</li><li><a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">InvokeDynamic: Actually Useful?</a>
</li><li><a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">A First Taste of InvokeDynamic</a>
</li><li><a href="http://blog.headius.com/2011/08/invokedynamic-in-jruby-constant-lookup.html">Invokedynamic in JRuby: Constant Lookup</a>
</li><li><a href="https://github.com/Sable/soot/wiki/Java%27s-Invokedynamic">Java's Invokedynamic</a>
</section>
<br>
<hr>
<p><a href="index.html">Home</a></p>
<p>Last updated on 2020-05-02</p></div>
</body>
</html>

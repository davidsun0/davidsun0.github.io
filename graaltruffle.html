<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#0050D0">

<meta name="author" content="David Sun">
<link rel="stylesheet" type="text/css" href="azure.css">
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
<title>Creating a Language with Graal + Truffle</title>
</head>

<body>
<section id="body">
<!-- body -->
<svg width="3em" height="3em" style="float:left; vertical-align:middle;padding-right: 1em">
<a href="index.html"><rect x="0" y="0" width="3em" height="3em" rx="0.5em" ry="0.5em"/></a>
</svg>
<h1 class="title" id="Creating a Language with Graal + Truffle">Creating a Language with Graal + Truffle</h1>
<h2 id="Resources Used">Resources Used</h2>
<h3 id="One VM to Rule Them All (Talk by Oracle)">One VM to Rule Them All (Talk by Oracle)</h3><p>
Introduction to Truffle and basic tutorial on its usage with SimpleLanguage
</p>
<ul><li><a href="https://www.youtube.com/watch?v=FJY96_6Y3a4">One VM to Rule Them All, One VM to Bind Them</a>
</li><li><a href="https://lafo.ssw.uni-linz.ac.at/pub/papers/2016<i>PLDI</i>Truffle.pdf">One VM to Rule Them All Slides [PDF]</a>
</li><li><a href="https://github.com/graalvm/simplelanguage">SimpleLanguage Github</a>
</li><li><a href="simple.html">My Notes on SimpleLanguage</a>
</li></ul>

<h3 id="Language Implementations in Truffle">Language Implementations in Truffle</h3>
<ul><li><a href="http://cesquivias.github.io/tags/truffle.html">Mumbler Blog Posts</a>
</li><li><a href="https://github.com/cesquivias/mumbler">Mumbler (Github)</a>
</li><li><a href="https://epub.jku.at/obvulihs/content/pageview/508383">TruffleClojure</a>
</li><li><a href="http://ssw.jku.at/General/Staff/ManuelRigger/thesis.pdf">Truffle/C (PDF)</a>
</li></ul>
<p>
Mumbler is a simple dialect of Lisp made to demonstrate Truffle's features.
</p>
<h3 id="Other Reading">Other Reading</h3>
<ul><li><a href="https://blog.plan99.net/graal-truffle-134d8f28fb69">Graal & Truffle</a>
</li><li><a href="https://medium.com/graalvm/graalvm-ten-things-12d9111f307d">Top 10 Things to do with GraalVM</a>
</li></ul>
<h3 id="Reference">Reference</h3>
<ul><li><a href="https://www.graalvm.org/truffle/javadoc/">Truffle Javadoc</a>
</li></ul>
<h1 id="Truffle Notes">Truffle Notes</h1>
<p>
These notes are mainly based on the <a href="https://www.youtube.com/watch?v=FJY96_6Y3a4">One VM to Rule Them All, One VM to Bind Them</a>
talk. The talk is focused on <a href="simple.html">SimpleLanguage</a>, which was created to
demonstrate Truffle's features.
</p>
<h2 id="Implementing Conditionals: SLIfNode">Implementing Conditionals: SLIfNode</h2>
<p>
All AST Nodes inherit from <code>com.oracle.truffle.api.nodes.Node</code>
<ul><li><code>Node</code> provides basic AST manipulation functionality (get parent, get children)
</li></ul></p>
<p>
Example: implementing an if node
</p>
<p>
Source code: <code>com.oracle.truffle.sl.nodes.controlflow.SLIfNode</code>
</p>
<h3 id="The Manual Way">The Manual Way</h3>
<p>
The node has three children: one expression node and two statement nodes.
The expression node is evaluated first, and then one of the two statement nodes will
be evaluated after that.
</p>
<ul><li>Create three fields in the <code>SLIfNode</code> class, one for each child
</li><li>Annotate each child with <code>@Child</code>
</li><li>Write a SLIfNode constructor to set the three children
</li><li>Implement logic in <code>ifNode.executeVoid(VirtualFrame)</code>
</li></ul>
<code class="codeBlock">public final class SLIfNode extends SLStatementNode {
    @Child private SLExpressionNode conditionNode;
    @Child private SLStatementNode thenNode;
    @Child private SLStatementNode elseNode;
    ...
}
</code>
<h3 id="With Truffle Annotations">With Truffle Annotations</h3>
<p>
Use Truffle's annotations to automatically generate this code: Annotate the class to provide
information about its children.
</p>
<p>
For example, <code>SLAddNode</code> performs addition on a left and right child.
</p>
<code class="codeBlock">@NodeChildren({@NodeChild(&quot;leftNode&quot;), @NodeChild(&quot;rightNode&quot;)})
public class SLAddNode extends SLExpressionNode {

    @Specialization    
    long add(long left, long right) {
        return left + right;
    }
    ...
}
</code>
<h3 id="Increasing perfomance via profiling">Increasing perfomance via profiling</h3>
<p>
Implement branch prediction with <code>com.oracle.truffle.api.profiles.ConditionProfile</code>:
</p>
<ul><li>create an instance with <code>ConditionProfile.createCountingProfile()</code> in the objects'
initializer
</li><li>wrap evaluation of the condition node in <code>conditionProfile.profile()</code>
</li></ul>
<h2 id="AST Node Optimization: Specializations">AST Node Optimization: Specializations</h2>
<p>
Specializations can increase language performance. For SimpleLanguage, even though it
has arbitrary precision integers, in practice programs are much more likely to be working
with small numbers. It would be a waste to use Java's BigInteger for all calculations.
</p>
<p>
Truffle allows SimpleLanguage's integers to be backed by long or BigInteger and it can
automatically convert as needed. For this, we will need:
<ul><li>A function detailing the implicit conversion in the type system (<code>SLTypes</code>)
</li><li>Special functions in arithmetic nodes which can handle long and BigInteger
</li></ul></p>
<p>
For the addition node, we first implement the logic for adding two long values.
To upcast to BigInteger when necessary, we use <code>Math.addExact</code>, which will throw
and ArithmeticException error when the addition overflows.
</p>
<code class="codeBlock">@NodeChildren({@NodeChild(&quot;leftNode&quot;), @NodeChild(&quot;rightNode&quot;)})
public class SLAddNode extends SLExpressionNode {
    ...

    @Specialization(rewriteOn = ArithmeticException.class)
    long add(long left, long right) {
        return Math.addExact(left, right);
    }

    @Specialization
    BigInteger add(BigInteger left, BigInteger, right) {
        return left.add(right);
    }

    ...
</code>
<p>
When the addition with longs fails with an ArithmeticException, the next specialization
will be attempted. If that specialization has a rewrite, Truffle will then continue
down the list of specializations (in the order of the source code).
</p>
<p>
Furthermore, the addition operator can be overloaded to take strings. In SimpleLanguage,
addition with strings performs concatenation. To avoid concatenating two integers,
we use the type system and gaurds to check the types of the arguments. (Note that in
SimpleLanguage, integers cannot be automatically cast to strings).
</p>
<p>
To implement string concatenation with the + operator, simply write a specialization that takes
Strings as arguments. The gaurd and isString function checks to see that at least one
of the arguments is of type String.
</p>
<code class="codeBlock">    ...

    @Specialization(gaurds = &quot;isString(left, right)&quot;)
    String add(Object left, Object right) {
        return &quot;&quot; + left + right;
    }

    static boolean isString(Object left, Object right) {
        return left instanceof String || right instanceof String;
    }
}
</code>
<p>
If no specializations match or if gaurds prevent any specializations match, Truffle will
automatically throw a type error.
</p>
<h2 id="Implementing expressions: SLExpressionNode">Implementing expressions: SLExpressionNode</h2>
<ul><li>Can provide <code>executeLong</code>, <code>executeBoolean</code>, etc for performance speedups to avoid
interpreter type unboxing (e.g. Java's <code>bool</code> vs <code>Boolean</code>)
</li></ul>
<h2 id="Implementing code blocks: SLBlockNode">Implementing code blocks: SLBlockNode</h2>
<p>
BlockNode contains a block of code and evaluates every child.
</p>
<ul><li>Create a final array of SLStatementNode
</li><li>Annotate with <code>@Children</code>
</li></ul>
<code class="codeBlock">@ExplodeLoop
@Override
public void executeVoid(VirtualFrame frame) {
    for (SLStatementNode bodyNode : bodyNodes) {
        bodyNode.executeVoid(frame);
    }
}
</code>
<ul><li><code>@ExplodeLoop</code> causes Truffle to unroll the loop instead of iterating over bodyNodes
</li><li>This is possible because bodyNodes is final, so the number of iterations is known
</li></ul>
<h2 id="Control through multiple execution frames">Control through multiple execution frames</h2>
<p>
In SLReturnNode, throw a <code>SLReturnException</code>, and catch this exception in the function
AST node. Truffle removes the exception overhead.
</p>
<h2 id="Local Variables and Frame Types">Local Variables and Frame Types</h2>
<p>
//TODO 1:21:00
</section>
<br>
<hr>
<p><a href="index.html">Home</a></p>
<p>Last updated on 2020-03-30</p>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#0050D0">

<meta name="author" content="David Sun">
<link rel="stylesheet" type="text/css" href="azure.css">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
<title>Lateral Lisp: A Journal</title>
</head>

<body>
<div id="container">
<section id="body">
<!-- body -->
<svg width="3em" height="3em" style="float:left; vertical-align:middle;padding-right: 1em">
<a href="index.html"><rect x="0" y="0" width="3em" height="3em" rx="0.5em" ry="0.5em"/></a>
</svg>
<h1 class="title" id="Lateral Lisp: A Journal">Lateral Lisp: A Journal</h1>
<p>
Just some thoughts and ideas on writing my own Lisp dialect.
</p>
<p>
<ul>
<li><a href="#glorified">2020-03-14 A Glorified Assembler</a></li>
<li><a href="#reflection">2020-02-16 Reflection on Lateral Version -1</a></li>
<li><a href="#closure">2019-12-01 The Lambda-Closure Problem</a></li>
<li><a href="#lambda_pass">2019-11-23 A new pass for Lambdas</a></li>
<li><a href="#updates">2019-08 Status Updates</a></li>
</ul>
</p>
<p>
<h1 id="glorified">A Glorified Assembler</h1>
2020-03-14
</p>
<p>
Happy half-tau day!
</p>
<p>
So... I think I made my language too powerful. At this point I'm not sure if I
can even call it a programming language anymore. It just feels like a glorified
JVM Bytecode assembler.
</p>
<h2 id="Special Forms">Special Forms</h2>
<p>
In all programming languages, there are reserved keywords which serve as the
foundation on which all programs stand. You know, stuff like <code>class</code>, <code>def</code>,
<code>import</code>, and the like. Lisp has been known for having a very small number of
keywords, but so far I think I can do with fewer.
</p>
<p>
Even things as basic as <code>if</code> can be written as a macro. With the JVM bytecodes
as my fundamental building blocks, I can build almost anything.
</p>
<p>
The building blocks I need are to define functions, define macros, and write
inline assembly. That's it.
</p>
<p>
See? It's just a glorified assembler now. Although being able to run code at
compile time is pretty unique...
</p>
<p>
<br>
<hr><br>
</p>
<p>
<h1 id="reflection">Reflection on Lateral Version -1</h1>
2020-02-16
</p>
<p>
As of 2020-02-02, I've decided to abandon what I'm calling Lateral Version -1.
(The rewrite will be Lateral Version 0. Ever heard of a -1 indexed versioning
system before? ;D)
I worked on this code from 2019-02-01 to 2020-02-01 and it just feels like I've
written myself into a corner. I'm starting fresh with all the experience I've
gained.
</p>
<h2 id="So why rewrite?">So why rewrite?</h2>
<p>
What made Lateral -1 a pain to work with in the end was probably the result of
a misguided goal. My aim was to have a self-hosting language as soon as
possible. Bad idea when writing your first language. To reach this goal, I
removed Java code and replaced it with Lateral as much as possible.
</p>
<p>
The problems:
<ul><li>The Lateral compiler is slow
</li><li>No good tools to debug Lateral
</li><li>Therefore it's hard to develop in Lateral
</li></ul></p>
<p>
You can see how I wrote myself into a corner. The language was still immature,
so I was shooting myself in the foot by removing the Java parts.
</p>
<p>
I would try to add a new feature to the compiler, but it was slow and painful
to write and test. This may be a little weird to think about - then I would
try to use the new feature in the compiler itself. Of course when I actually
used the feature, I would find that there was a bug in the implementation.
</p>
<p>
That mean the compiler couln't compile itself and I would have to revert my
code changes (kids, this is why you use Git) and basically restart development
on the feature I was working on. All of it had to be redone. This process could
take several cycles of writing code and reverting changes before I finally got
it right.
</p>
<p>
This got to the point where it was painful to write new code, and well, here we
are.
</p>
<h2 id="What am I going to do differently?">What am I going to do differently?</h2>
<p>
So what did I learn from my mistakes? First of all, don't jump the gun on self
hosting. While it sounds really cool to have a compiler compile itself, the
main concern should still be productivity. Even mainstream languages like R and
Python have large parts of their core library written in other languages.
If my memory serves me right, R is written in Fortran and C and Python's
engine and some libraries are written in C.
</p>
<p>
Also, this time, I'm not going to write a compiler in Lateral. I'm going to write
a bytecode assembler. An assembler would let me write much more lower level
code in Lateral.
</p>
<p>
An unrelated side note: This isn't related to any failures, but now I want to
play with Java's invokedynamic. I think it could help with hot swapping method
definitions and the like.
</p>
<p>
<br>
<hr><br>
</p>
<p>
<h1 id="closure">The Lambda-Closure Problem</h1>
2019-12-01
</p>
<p>
For my first crack at this problem, I'll assume that all lambdas are closing
over some internal variable. This is the general case, and then I can work on
optimizations for things like calling a lambda immediately after its made.
</p>
<p>
If a lambda is closing over an internal variable, the lambda must be made at
runtime. The compiler should emit code to construct the lambda, not the lambda
itself.
</p>
<p>
<h1 id="lambda_pass">A new pass for lambdas</h1>
2019-11-23
</p>
<p>
I'm working on compiling anonymous fuctions and am faced with a new problem.
</p>
<p>
First of all, while compiling one function, the compiler may have to compile
another function. And that function may have even more functions inside of it.
Since functions are a type of object, the compiler needs to compile a Lisp
lambda into a Java function and wrap it inside of an object.
</p>
<p>
It might be useful to add a new compiler pass. Each lambda will be left alone
and only marked with the token <code>:labmda</code> in the regular ast to ir step. Then
the new pass will filter out these lambdas. The lambdas will be compiled just
like any other function, and the slot in the ir will be replaced with a `:push
lambda-numberX` token.
</p>
<p>
At the same time, the lambda will be labeled with the same <code>lambda-numberX</code>
symbol. The lambda object will need to be made in the static initializer.
</p>
<p>
The new problem is that an anonymous function may be used as either a function
or as an object. If the first happens, then the compiler needs to generate code
to call the function object. The ast to ir step will have to generate the start
of a function call to distinguish the different uses.
</p>
<code class="codeBlock">; original ast
(a b c d)

; current ir
(:push b)
(:push c)
(:push d)
(:funcall a :argc 3)

; new ir
(:call)
(:push a)
(:push b)
(:push c)
(:push d)
(:funcall :argc 4)
</code>
<p>
The downside to this approach is that there needs to be a pass to determine
if a variable should be looked up in the global environment or from the
function's arguments. The upside is that this will simplify calling functions
that were passed as arguments or created from a higher order function.
</p>
<p>
I still have no idea how to implement closures though. I'll probably have to
modify this solution if I want the anonymous functions to close over variables
in the outer scope.
</p>
<p>
Basically what I'm trying to say here is that the JVM makes it a pain to
implement first class functions.
</p>
<p>
<br>
<hr><br>
</p>
<p>
<h1 id="updates">Status Updates: 2019/08/27 ~ 2019/10/12</h1>
</p>
<h2 id="October 12">October 12</h2>
<p>
The interpreter is now self-hosting. A C99 compiler and a JRE are required.
Here are the steps to reproduce it:
</p>
<code class="codeBlock">Lateral/bootstrap $ make
Lateral/bootstrap $ ./a.out jvmclass.lisp
Lateral/bootstrap $ mv Lateral.class ../jvm/
Lateral/bootstrap $ cd ../jvm/
Lateral/jvm $ javac *.java
</code>
<p>
This produces the Lateral interpreter written in Lateral. To show that it
is self hosting, the following command in the repl will produce a functionally
equivalent <code>Lateral.class</code> file written to <code>LateralB.class</code>.
</p>
<code class="codeBlock">Lateral/jvm $ java Helper
user&gt; (include &quot;jvmclass.lisp&quot;)
</code>
<p>
If <code>Lateral.class</code> is replaced with <code>LateralB.class</code> and the previous two
commands are run again, the new <code>LateralB.class</code> will be an exact replica of
the old one.
</p>
<h2 id="October 4">October 4</h2>
<p>
The compilation target is now going to be JVM Bytecode. It's more fun than
compiling to C. This also has the side effect of opening up the possibility of
a JIT compiler. 
</p>
<p>
Code for general compilation is in <code>compiler.lisp</code>, while JVM-specific code now
resides in <code>jvmclass.lisp</code>. There is functionality to call native functions and
to call other compiled functions.
</p>
<p>
The only thing left to do is to be able to compile all of the special forms.
Generating bytecode should be straightforward for everything except <code>let</code> and
<code>lambda</code>. Compiling let involves setting local variables and resolving
bindings in nested let statements. Lambdas are difficult because the JVM is
not designed for first class functions. Anonymous functions are like let
statements, but clojures and passing functions as objects will be interesting
to compile.
</p>
<h2 id="September 9">September 9</h2>
<p>
Code destructuring is mostly complete. Compiling to C is coming up on the
horizon. Here is an example of the current code compiling the distance formula:
</p>
<code class="codeBlock">&gt; (def distance-code (quote (sqrt (+ (sq (- x1 x2)) (sq (- y1 y2))))))
&gt; (use-define (destr2 distance-code))
=&gt; (&quot;Object *temp_0 = funcall(-, x1, x2);&quot;
    &quot;Object *temp_1 = funcall(sq, temp_0);&quot;
    &quot;Object *temp_2 = funcall(-, y1, y2);&quot;
    &quot;Object *temp_3 = funcall(sq, temp_2);&quot;
    &quot;Object *temp_4 = funcall(+, temp_1, temp_3);&quot;
    &quot;Object *temp_5 = funcall(sqrt, temp_4);&quot;
    &quot;return temp_5;&quot;)
</code>
<p>
The next steps to take are to implement function lookup. Since <code>-</code> cannot be
used as a variable in C, the compiler must be able to lookup the handwritten C
function <code>la_diff</code>, which implements subtraction. The code should read
<code>funcall(la_diff, x1, x2)</code>.
</p>
<p>
Next, I want to implement the <code>if</code> special form, which should allow me to
compile most of <code>core.lisp</code> into C.
</p>
<h2 id="August 27">August 27</h2>
<p>
I consider the interpreter be mostly feature complete. It can read a lisp file
from disk and interpret it. The most important special forms have been
implemented, as well as macros. I will definitely need string manipulation
for compiling to C, but they have yet to be written.
</p>
</section>
<br>
<hr>
<p><a href="index.html">Home</a></p>
<p>Last updated on 2020-03-29</p></div>
</body>
</html>
